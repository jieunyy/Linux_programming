## 사용자와 그룹
#### 다중 사용자 시스템
리눅스 사용 시 가장 먼저 하는 일은 로그인이다.   
왜 로그인이 필요한가?   
이는 리눅스가 **다중 사용자 시스템**이기 때문이다.
* 리눅스가 아니라 iOS, 안드로이드 등도 그렇다.

사용면에서는 1인용 보다는 다중 사용자가 좋아보이지만,     
반대로 운영 체제의구현과 사용 관점에서는 복잡도가 높아진다.
* 그러나 결국, **다중 사용자를 전제로 한 설계가 더 안전한 시스템의 근간**이 된다.

#### 권한의 분할
파일을 특정 사용자만 수정/삭제할 수 있또록 하기 위해 사용자별 파일에 대한 권한(permission)이 적용된다.     
따라서 사용자별로 읽기/쓰기/실행 가능한 파일이 다르게 되는 것이다.   
* 모든 파일에 모든 권한을 가지는 사용자를 **슈퍼 사용자**라고 하고, 보통 **root**라는 이름을 가진다.   
* 슈퍼사용자는 모든 파일을 수정, 삭제, 모든 프로세스를 정지할 수 있는 권한도 가진다.

#### 그룹
그룹을 사용하면 권한을 더 유연하게 배정할 수 있다.   
그룹에 권한을 부여하면 그 그룹의 멤버 전원에게 해당 권한이 부여된다.


#### 기본 그룹
각 사용자는 항상 최소한 한 개의 그룹에 소속되어 있어야 한다.
* 보통 이 최초의 그룹을 기본 그룹이라고 하는데 useradd 명령어로 사용자를 만들 때 -g 옵션을 주어 지정하는 것이 가능하다.

#### 부가 그룹
시스템 관리자는 하나의 사용자를 기본 그룹 이외에 여러 그룹에 한꺼번에 추가하는 것도 가능하다.
* 사용자를 만들 때 useradd 명령어에 -G 옵션으로 지정하거나,
* 만들어진 사용자에 대해 VIGR 명령어를 사용하여 추가할 수 있다.

## 권한
사용자, 그룹별로 특정 파일에 대한 사용을 허가/비허가 하는 것   
이를 위해 리눅스에서는 개별 파일별로 소유자와 소유 그룹이 반드시 존재한다.   
그러면 다음 세 집단에 대해 서로 다른 권한 설정이 가능하다.
* 파일을 소유하는 사용자
* 파일을 소유하는 그룹에 속한 사용자
* 그 외의 사용자
권한의 종류는 다음 세 가지다.
* 읽을 수 있는 권한(read, r)
* 쓸 수 있는 권한(write, w)
* 실행(execute, x)
즉, 총 아홉 개의 설정이 가능하다.
```bash
ls -l
```
이때, 맨 왼쪽에 표시되는 문자열에서 첫번째 문자를 제외한 아홉 개의 문자가 권한을 나타낸다.
|소유 사용자 | 소유 그룹 | 그 외|
|---|---|---|
위 세 요소 각각에 아래 권한이 적용되는 것이다.

|  | 읽기 | 쓰기 | 실행 |
|---|---|---|---|
| 가능 | r | w | x |
| 불가능 | - | - | - |

#### 구체적인 예
rw-r--r--
* 소유자만 읽고 슬 수 있고, 그 외의 사용자는 읽을 수만 있다. 가장 일반적
rwxr-xr-x
* 소유자는 읽고 쓸 수 있고, 그 외의 소유자는 읽고 실행만 할 수 있다.
* 프로그램이나 디렉터리에 사용하는 패턴이다.
rw-------
* 소유자만 읽고 쓸 수 있다.
* SSH의 비밀 키, 본인 이외 사용자가 봐서는 안 될 파일에 적용되는 패턴이다.

#### 권한의 8진수
rwxr-xr-x 등과 같은 표기법 이외에 권한을 표기하는 다른 방법이 있다.  
대표적인 것으로 각 문자를 1비트의 수치로 보는 8진 표기 방식
* r=4, w=2, x=1, -=0이 된다.
* rwx = 7, r-x = 5
* rwxr-xr-x = 755
이러한 표기는 비트 연산을 기반으로 하기에 C언어에서 그대로 활용하기 쉽다.

#### 디렉터리 권한
디렉터리 권한은 일반 파일과 조금 다르게 적용된다.
* 읽기 권한이 있으면, ls 명령어 등으로 디렉터리의 파일 목록을 확인할 수 있다.
* 쓰기 권한이 있으면, 그 안에 새로운 파일을 쓰거나 삭제할 수 있다.
* 실행 가능 권한이 있으면 그 안의 파일에 접근할 수 있다.
디렉터리의 실행 권한이 없으면 그 안에 있는 파일의 권한과 상관없이 접근(읽기/쓰기/실행 전부)이 일절 불가능하다.

## 자격
사용자 A가 소유하고 있는 파일이 있을 떄, 이 파일의 권한이 rw-r--r--이면   
사용자 A로서 접근하여 해당 파일을 읽고 쓸 수 있다.
* 이때, 사용자 A가 접근한다는 것은 '사용자 A의 속성을 가진 프로세스가 접근한다'이다.
* 리눅스 상에서 활동하는 주체는 사람이 아니라 프로세스이기 때문이다.
이렇게 프로세스가 가지는 사용자의 속성을 **자격 증명**이라고 한다. 즉, **증명서**다.
*로그인을 통해 사용자의 증명서를 가진 프로세스가 시스템상에 생성되는 것이다.*

#### 사용자 이름과 사용자 ID
리눅스 커널은 사용자 이름 대신, 사용자 이름에 대응하는 사용자 ID(숫자)를 사용한다.
* 파일의 소유자도 사용자 ID로 기록되며, 프로세스의 자격 증명서도 ID를 기반으로 다뤄진다.
* ls 시 파일의 소유자 이름이 출력되는데, 이는 ls 명령어가 매번 ID를 이름으로 변환하는 것에 불과하다.

#### 사용자 데이터 베이스
사용자의 ID 매핑은 /etc/passwd에 작성되어 있다.
* 해당 디렉토리에는 한 줄 단위로 사용자 정보가 등록되어 있다.
* 각 줄은 콜론(:)으로 항목이 구분되어 있는데
* 사용자 이름 : x(비밀번호 등록 여부, 등록됨) : 사용자 ID : 그룹 ID
<br/>
그러나 그룹 ID가 1이라고 하면 어떤 그룹인지 알기 어렵다.     
그룹 ID와 그룹 이름의 매핑은 /etc/group에 기록되어 있다.

* 각 줄은 콜론(:)으로 항목이 구분되어 있는데
* 그룹 이름 :  x(비밀번호 등록 여부, 등록됨) : 그룹ID : 이 그룹이 부가 그룹인 사용자

#### 사용자 데이터 베이스 접근
만드는 프로그램에서 사용자 이름과 ID를 다루기 위해 직접 /etc/passwd나 /etc/group에 접근하면 안 된다.
* 보안 상으로도, 시스템적으로도 위험하다.    
대신 /etc/passwd나 /etc/group에 액세스하기 위한 전용 API가 존재한다.

 왜 API를 사용하는가? 그것은 사용자 정보가 반드시 /etc/passwd에 있다고 단정할 수 없기 떄문이다.
 * 중소규모 조직을 위한 NIS(Network Information Center)나 현재던인 LDAP(Lightweight Directory Access Protocol)
 * 와 같은 시스템을 사용하여 복수의 머신에서 사용자의 정보를 공유하는 경우가 있다.
